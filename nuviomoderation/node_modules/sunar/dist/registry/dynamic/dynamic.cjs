'use strict';

var discord_js = require('discord.js');
var index_cjs = require('../../utils/index.cjs');

var __defProp = Object.defineProperty;
var __name = (target, value) => __defProp(target, "name", { value, configurable: true });
async function registerCommands(application) {
  const commands = index_cjs.getSunarApplicationCommands();
  const isGuildCommand = /* @__PURE__ */ __name((command) => command.config.guildIds && command.config.guildIds.length > 0, "isGuildCommand");
  const globalCommands = commands.filter((c) => !isGuildCommand(c));
  const guildCommands = commands.filter(isGuildCommand);
  let globalCommandsResult = new discord_js.Collection();
  if (globalCommands.length > 0) {
    const result = await application.commands.set(globalCommands.map((c) => c.data));
    globalCommandsResult = result;
  }
  const guildCommandsResults = [];
  if (guildCommands.length > 0) {
    const mappedGuilds = {};
    for (const { config, data } of guildCommands) {
      if (!config.guildIds || config.guildIds.length <= 0) continue;
      for (const guildId of config.guildIds) {
        if (mappedGuilds[guildId]) mappedGuilds[guildId].push(data);
        else mappedGuilds[guildId] = [data];
      }
    }
    for (const entries of Object.entries(mappedGuilds)) {
      const [guildId, command] = entries;
      const result = await application.commands.set(command, guildId);
      guildCommandsResults.push(result);
    }
  }
  return {
    globalCommands: globalCommandsResult,
    guildCommands: guildCommandsResults
  };
}
__name(registerCommands, "registerCommands");

exports.registerCommands = registerCommands;
//# sourceMappingURL=dynamic.cjs.map
//# sourceMappingURL=dynamic.cjs.map